<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>C++ Documentation &mdash; AuDi documentation</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootswatch-3.3.6/spacelab/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.6/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="AuDi documentation" href="../index.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><img src="../_static/audi_mini_logo.png">
           </a>
        <span class="navbar-text navbar-version pull-left"><b>0.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../installation.html">Install</a></li>
                <li><a href="../quickstart.html">Quick Start</a></li>
                <li><a href="index.html">Docs</a></li>
                <li><a href="../theory.html">Theory</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <div class="section" id="c-documentation">
<h1><a class="toc-backref" href="#id1">C++ Documentation</a><a class="headerlink" href="#c-documentation" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#c-documentation" id="id1">C++ Documentation</a><ul>
<li><a class="reference internal" href="#classes" id="id2">Classes</a><ul>
<li><a class="reference internal" href="#gdual-generalized-dual-number-class" id="id3">gdual: Generalized dual number class.</a></li>
</ul>
</li>
<li><a class="reference internal" href="#functions" id="id4">Functions</a><ul>
<li><a class="reference internal" href="#exp-overload-for-the-exponential" id="id5">exp: Overload for the exponential.</a></li>
<li><a class="reference internal" href="#log-overload-for-the-logarithm" id="id6">log: Overload for the logarithm.</a></li>
<li><a class="reference internal" href="#pow-overload-for-pow-const-gdual-double" id="id7">pow: Overload for pow(const gdual&amp;, double)</a></li>
<li><a class="reference internal" href="#pow-overload-for-pow-const-gdual-int" id="id8">pow: Overload for pow(const gdual&amp;, int)</a></li>
<li><a class="reference internal" href="#pow-overload-for-pow-double-const-gdual" id="id9">pow: Overload for pow(double, const gdual&amp;)</a></li>
<li><a class="reference internal" href="#pow-overload-for-pow-const-gdual-const-gdual" id="id10">pow: Overload for pow(const gdual&amp;, const gdual&amp;)</a></li>
<li><a class="reference internal" href="#sin-overload-for-the-sine" id="id11">sin: Overload for the sine.</a></li>
<li><a class="reference internal" href="#cos-overload-for-the-cosine" id="id12">cos: Overload for the cosine.</a></li>
<li><a class="reference internal" href="#sin-and-cos-computes-both-at-once" id="id13">sin_and_cos: Computes both at once</a></li>
<li><a class="reference internal" href="#tan-overload-for-the-tangent" id="id14">tan: Overload for the tangent.</a></li>
<li><a class="reference internal" href="#atan-overload-for-the-inverse-tangent" id="id15">atan: Overload for the inverse  tangent.</a></li>
<li><a class="reference internal" href="#acos-overload-for-the-inverse-cosine" id="id16">acos: Overload for the inverse cosine.</a></li>
<li><a class="reference internal" href="#asin-overload-for-the-inverse-sine" id="id17">asin: Overload for the inverse sine.</a></li>
<li><a class="reference internal" href="#sinh-overload-for-the-hyperbolic-sine" id="id18">sinh: Overload for the hyperbolic sine.</a></li>
<li><a class="reference internal" href="#cosh-overload-for-the-hyperbolic-cosine" id="id19">cosh: Overload for the hyperbolic cosine.</a></li>
<li><a class="reference internal" href="#sinh-and-cosh-computes-both-at-once" id="id20">sinh_and_cosh: Computes both at once</a></li>
<li><a class="reference internal" href="#tanh-overload-for-the-hyperbolic-tangent" id="id21">tanh: Overload for the hyperbolic tangent.</a></li>
<li><a class="reference internal" href="#atanh-overload-for-the-inverse-hyperbolic-tangent" id="id22">atanh: Overload for the inverse hyperbolic tangent.</a></li>
<li><a class="reference internal" href="#acosh-overload-for-the-inverse-hyperbolic-cosine" id="id23">acosh: Overload for the inverse hyperbolic cosine.</a></li>
<li><a class="reference internal" href="#asinh-overload-for-the-inverse-hyperbolic-sine" id="id24">asinh: Overload for the inverse hyperbolic sine.</a></li>
<li><a class="reference internal" href="#erf-overload-for-the-error-function" id="id25">erf: Overload for the error function</a></li>
<li><a class="reference internal" href="#sqrt-overload-for-the-square-root" id="id26">sqrt: Overload for the square root.</a></li>
<li><a class="reference internal" href="#cbrt-overload-for-the-cubic-root" id="id27">cbrt: Overload for the cubic root.</a></li>
<li><a class="reference internal" href="#abs-overload-for-the-absolute-value" id="id28">abs: Overload for the absolute value.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="classes">
<h2><a class="toc-backref" href="#id2">Classes</a><a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h2>
<div class="section" id="gdual-generalized-dual-number-class">
<h3><a class="toc-backref" href="#id3">gdual: Generalized dual number class.</a><a class="headerlink" href="#gdual-generalized-dual-number-class" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt>
<span class="target" id="AuDiclassaudi_1_1gdual"></span><em class="property">template </em>&lt;<em class="property">typename</em> Cf&gt;</dt>
<dt id="_CPPv2N4audi5gdualE">
<span id="audi::gdual"></span><em class="property">class </em><code class="descclassname">audi::</code><code class="descname">gdual</code><a class="headerlink" href="#_CPPv2N4audi5gdualE" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalized dual number class. </p>
<p>This class represents a generalized dual number, in a nutshell, a truncated multivariate Taylor polynomial. Using the multi-index notation, a generalized dual number may be written as: <div class="math">
\[ T_f(\mathbf x) = \sum_{|\alpha| = 0}^m \frac{(\mathbf x-\mathbf a)^\alpha}{\alpha!}(\partial^\alpha f)(\mathbf a) \]</div>
</p>
<p>and thus depends on the order <span class="math">\(m\)</span> as well as on the expansion point <span class="math">\(\mathbf a\)</span>. All arithmetic operators +,*,/,- are overloaded so that the Taylor expansion of arithmetic computations is obtained. A basic use case, where <span class="math">\(m = 2\)</span>, <span class="math">\(\mathbf a = [1.2, -0.1]\)</span> and <span class="math">\(f = \frac{x1+x2}{x1-x2}\)</span> is thus:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">gdual</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">x1</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="s2">&quot;x1&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">gdual</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">x2</span><span class="p">(</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="s2">&quot;x2&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">x1</span><span class="o">+</span><span class="n">x2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">x2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
</pre></div>
</div>
</p>
<p>resulting in the output:</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="mf">0.118343</span><span class="o">*</span><span class="n">dx1</span><span class="o">+</span><span class="mf">0.846154</span><span class="o">+</span><span class="mf">1.42012</span><span class="o">*</span><span class="n">dx2</span><span class="o">+</span><span class="mf">1.0924</span><span class="o">*</span><span class="n">dx2</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mf">0.0910332</span><span class="o">*</span><span class="n">dx1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mf">1.00137</span><span class="o">*</span><span class="n">dx1</span><span class="o">*</span><span class="n">dx2</span>
</pre></div>
</div>
</p>
<p>Integration and differentiation are also implemented so that the generalized dual computations are formally made in a differential algebra.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The class can be instantiated with any type that is suitable to be a coefficient in a piranha polynomial ( piranha::is_cf&lt;Cf&gt;::value must be true). Classical examples would be double, float, std::complex&lt;double&gt;, and the audi::vectorized_double type. If piranha::is_differentiable&lt;Cf&gt;::value is also true then derivation and integration are availiable.</dd>
<dt><strong>Author</strong></dt>
<dd>Dario Izzo (<a class="reference external" href="mailto:dario&#46;izzo&#37;&#52;&#48;gmail&#46;com">dario<span>&#46;</span>izzo<span>&#64;</span>gmail<span>&#46;</span>com</a>) </dd>
<dt><strong>Author</strong></dt>
<dd>Francesco Biscani (<a class="reference external" href="mailto:bluescarni&#37;&#52;&#48;gmail&#46;com">bluescarni<span>&#64;</span>gmail<span>&#46;</span>com</a>) </dd>
</dl>
</p>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Algebraic operators</p>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, <em class="property">typename</em> U&gt;</dt>
<dt id="_CPPv2plRK1TRK1U">
<span id="add-operator__TCR.UCR"></span><span class="target" id="AuDiclassaudi_1_1gdual_1aedf88fc2b910098026c5a285531489de"></span>gdual_if_enabled&lt;T, U&gt; <code class="descname">operator+</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d1</em>, <em class="property">const</em> U &amp;<em>d2</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2plRK1TRK1U" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded addition operator. </p>
<p>Implements the sum operation between truncated Taylor polynomials. <dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>In order for this overload to be active (SFINAE rules), at least one of the arguments must be an <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>, while the second argument may only be a double or int.</dd>
<dt><strong>Return</strong></dt>
<dd>the sum between d1 and d2 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d1</span></code> - <p>first <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument </p>
</li>
<li><code class="first docutils literal"><span class="pre">d2</span></code> - <p>second <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, <em class="property">typename</em> U&gt;</dt>
<dt id="_CPPv2miRK1TRK1U">
<span id="sub-operator__TCR.UCR"></span><span class="target" id="AuDiclassaudi_1_1gdual_1a73b9da1f799717756566fdf421ba764f"></span>gdual_if_enabled&lt;T, U&gt; <code class="descname">operator-</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d1</em>, <em class="property">const</em> U &amp;<em>d2</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2miRK1TRK1U" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded difference operator. </p>
<p>Implements the difference operation between truncated Taylor polynomials. <dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>In order for this overload to be active (SFINAE rules), at least one of the arguments must be an <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>, while the second argument may only be a double or int.</dd>
<dt><strong>Return</strong></dt>
<dd>the difference between d1 and d2 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d1</span></code> - <p>first <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument </p>
</li>
<li><code class="first docutils literal"><span class="pre">d2</span></code> - <p>second <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, <em class="property">typename</em> U&gt;</dt>
<dt id="_CPPv2mlRK1TRK1U">
<span id="mul-operator__TCR.UCR"></span><span class="target" id="AuDiclassaudi_1_1gdual_1af6e21f8aa99bf6cf4c9a14b49c32b2fe"></span>gdual_if_enabled&lt;T, U&gt; <code class="descname">operator*</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d1</em>, <em class="property">const</em> U &amp;<em>d2</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2mlRK1TRK1U" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded multiplication operator. </p>
<p>Implements the multiplication operation between truncated Taylor polynomials. <dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>In order for this overload to be active (SFINAE rules), at least one of the arguments must be an <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>, while the second argument may only be a double or int.</dd>
<dt><strong>Note</strong></dt>
<dd>The truncated polynomial multiplication operator is at the very heart of AuDi and its details / performances are those of the piranha multiplication algorithm which is, essentially, used.</dd>
<dt><strong>Return</strong></dt>
<dd>the (truncated) multiplication between d1 and d2 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d1</span></code> - <p>first <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument </p>
</li>
<li><code class="first docutils literal"><span class="pre">d2</span></code> - <p>second <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, <em class="property">typename</em> U&gt;</dt>
<dt id="_CPPv2dvRK1TRK1U">
<span id="div-operator__TCR.UCR"></span><span class="target" id="AuDiclassaudi_1_1gdual_1a193be1e6e87734564d3169f50fad648e"></span>gdual_if_enabled&lt;T, U&gt; <code class="descname">operator/</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d1</em>, <em class="property">const</em> U &amp;<em>d2</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2dvRK1TRK1U" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded division operator. </p>
<p>Implements the division operation between truncated Taylor polynomials. Essentially, defined (in case of two <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>) by a multiplication and the reciprocal rule:</p>
<p><div class="math">
\[ T_g = \frac 1{T_f} = \frac 1{f_0} \left(1 +\sum_{k=1}^m (-1)^k (\hat f / f_0)^k\right) \]</div>
</p>
<p>where <span class="math">\(T_f = f_0 + \hat f\)</span>.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>In order for this overload to be active (SFINAE rules), at least one of the arguments must be an <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>, while the second argument may only be a double or int.</dd>
<dt><strong>Return</strong></dt>
<dd>an audi:gdual containing the (truncated) multiplication between d1 and d2 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d1</span></code> - <p>first <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument </p>
</li>
<li><code class="first docutils literal"><span class="pre">d2</span></code> - <p>second <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T&gt;</dt>
<dt id="_CPPv2N4audi5gdualpLERK1T">
<span id="audi::gdual::add-assign-operator__TCR"></span><span class="target" id="AuDiclassaudi_1_1gdual_1a872b4c5b706644e07957f8748f14881b"></span>auto <code class="descname">operator+=</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d1</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi5gdualpLERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Add and assignment operator. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T&gt;</dt>
<dt id="_CPPv2N4audi5gdualmIERK1T">
<span id="audi::gdual::sub-assign-operator__TCR"></span><span class="target" id="AuDiclassaudi_1_1gdual_1a9d956e121c622cecc2913cf6f7b1a35b"></span>auto <code class="descname">operator-=</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d1</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi5gdualmIERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtract and assignment operator. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T&gt;</dt>
<dt id="_CPPv2N4audi5gdualmLERK1T">
<span id="audi::gdual::mul-assign-operator__TCR"></span><span class="target" id="AuDiclassaudi_1_1gdual_1af3dd7ca106ef935791bb90af61ca94df"></span>auto <code class="descname">operator*=</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d1</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi5gdualmLERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply and assignment operator. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T&gt;</dt>
<dt id="_CPPv2N4audi5gdualdVERK1T">
<span id="audi::gdual::div-assign-operator__TCR"></span><span class="target" id="AuDiclassaudi_1_1gdual_1acd17a19ede3b8f2c9c242afde47a8790"></span>auto <code class="descname">operator/=</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d1</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi5gdualdVERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Divide and assignment operator. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N4audi5gdualmiEv">
<span id="audi::gdual::sub-operator"></span><span class="target" id="AuDiclassaudi_1_1gdual_1aab667089333d0a3b0c00fe28b78be07d"></span><a class="reference internal" href="#_CPPv2N4audi5gdualE" title="audi::gdual">gdual</a> <code class="descname">operator-</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N4audi5gdualmiEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate operator. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N4audi5gdualplEv">
<span id="audi::gdual::add-operator"></span><span class="target" id="AuDiclassaudi_1_1gdual_1a1aeac2dd010ab0d110786e3f05b9f9ca"></span><a class="reference internal" href="#_CPPv2N4audi5gdualE" title="audi::gdual">gdual</a> <code class="descname">operator+</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N4audi5gdualplEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Identity operator. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Low-level interface</p>
<dl class="function">
<dt id="_CPPv2N4audi5gdual10_containerEv">
<span id="audi::gdual::_container"></span><span class="target" id="AuDiclassaudi_1_1gdual_1ae0689d092a3a03560b323adb2cbf95f3"></span>auto <code class="descname">_container</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi5gdual10_containerEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a mutable reference to the container of terms. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a reference to the internal container of terms. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N4audi5gdual10_containerEv">
<span class="target" id="AuDiclassaudi_1_1gdual_1a6ad909300a69adb547fe4ca7309226fd"></span>auto <code class="descname">_container</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N4audi5gdual10_containerEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a const reference to the container of terms. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a const reference to the internal container of terms. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N4audi5gdual5_polyEv">
<span id="audi::gdual::_poly"></span><span class="target" id="AuDiclassaudi_1_1gdual_1a958806e725263b3be6d3bbc71072ff6e"></span><em class="property">const</em> p_type &amp;<code class="descname">_poly</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N4audi5gdual5_polyEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a const reference to the polynomial. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a const reference to the internal polynomial. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N4audi5gdual5_polyEv">
<span class="target" id="AuDiclassaudi_1_1gdual_1ac63d8def18add6e0153078000133b70f"></span>p_type &amp;<code class="descname">_poly</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi5gdual5_polyEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a mutable reference to the polynomial. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a reference to the internal polynomial. </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv2N4audi5gdual5gdualERK5gdual">
<span id="audi::gdual::gdual__gdualCR"></span><span class="target" id="AuDiclassaudi_1_1gdual_1ae83d0582f97c2b85775a03cd9af95887"></span><code class="descname">gdual</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N4audi5gdual5gdualERK5gdual" title="audi::gdual::gdual">gdual</a>&amp;<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi5gdual5gdualERK5gdual" title="Permalink to this definition">¶</a></dt>
<dd><p>Defaulted copy constructor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N4audi5gdual5gdualERR5gdual">
<span id="audi::gdual::gdual__gdualRR"></span><span class="target" id="AuDiclassaudi_1_1gdual_1a081604095bb3a69bcd83dda2deccd0f8"></span><code class="descname">gdual</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N4audi5gdual5gdualERK5gdual" title="audi::gdual::gdual">gdual</a>&amp;&amp;<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi5gdual5gdualERR5gdual" title="Permalink to this definition">¶</a></dt>
<dd><p>Defaulted move constructor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N4audi5gdual5gdualEv">
<span id="audi::gdual::gdual"></span><span class="target" id="AuDiclassaudi_1_1gdual_1aba6cd0a818763a942eec4f87bdb6b0fa"></span><code class="descname">gdual</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi5gdual5gdualEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Default constuctor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N4audi5gdualD0Ev">
<span id="audi::gdual::~gdual"></span><span class="target" id="AuDiclassaudi_1_1gdual_1ab244b9535bc702f50e19ba40f53edf7c"></span><code class="descname">~gdual</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi5gdualD0Ev" title="Permalink to this definition">¶</a></dt>
<dd><p>Destructor (contains a sanity check) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N4audi5gdualaSERK5gdual">
<span id="audi::gdual::assign-operator__gdualCR"></span><span class="target" id="AuDiclassaudi_1_1gdual_1a649d6338d5b72d82716c03c40599ec85"></span><a class="reference internal" href="#_CPPv2N4audi5gdualE" title="audi::gdual">gdual</a> &amp;<code class="descname">operator=</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv2N4audi5gdualE" title="audi::gdual">gdual</a>&amp;<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi5gdualaSERK5gdual" title="Permalink to this definition">¶</a></dt>
<dd><p>Defaulted assignment operator. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N4audi5gdualaSERR5gdual">
<span id="audi::gdual::assign-operator__gdualRR"></span><span class="target" id="AuDiclassaudi_1_1gdual_1a1e399283e06a7cf794ea43cb6db2ebdc"></span><a class="reference internal" href="#_CPPv2N4audi5gdualE" title="audi::gdual">gdual</a> &amp;<code class="descname">operator=</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N4audi5gdualE" title="audi::gdual">gdual</a>&amp;&amp;<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi5gdualaSERR5gdual" title="Permalink to this definition">¶</a></dt>
<dd><p>Defaulted assignment operator. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N4audi5gdual19get_symbol_set_sizeEv">
<span id="audi::gdual::get_symbol_set_size"></span><span class="target" id="AuDiclassaudi_1_1gdual_1ad3c9a723a1e4b18c1eca33f22ca10de2"></span>auto <code class="descname">get_symbol_set_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N4audi5gdual19get_symbol_set_sizeEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the symbol set size. </p>
<p>Returns the size of the symbol set.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the size of the symbol set. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N4audi5gdual14get_symbol_setEv">
<span id="audi::gdual::get_symbol_set"></span><span class="target" id="AuDiclassaudi_1_1gdual_1ae4e63cf6d2c42993b1680bbabde50514"></span>std::vector&lt;std::string&gt; <code class="descname">get_symbol_set</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N4audi5gdual14get_symbol_setEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the symbol set size. </p>
<p>Returns the symbol set (not the differentials)</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the symbol set </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N4audi5gdual17extend_symbol_setERKNSt6vectorINSt6stringEEE">
<span id="audi::gdual::extend_symbol_set__std::vector:ss:CR"></span><span class="target" id="AuDiclassaudi_1_1gdual_1a227e8918bf4944d20793aa53c60fa835"></span>void <code class="descname">extend_symbol_set</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;std::string&gt; &amp;<em>sym_vars</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi5gdual17extend_symbol_setERKNSt6vectorINSt6stringEEE" title="Permalink to this definition">¶</a></dt>
<dd><p>Extends the symbol set. </p>
<p>Adds some symbolic variables to the current polynomial This is useful in situations where some variable <span class="math">\( dx\)</span> does not appear in the final polynomial but we still want to treat the Taylor expansion as a function of <span class="math">\( dx\)</span> too (for example when extracting the relative coefficient)</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">sym_vars</span></code> - <p>list of symbolic names. It must contain all symbolic names of the current polynomial. It may contain more. All symbols must start with the letter &#8220;d&#8221;.</p>
</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">std::invalid_argument</span></code> - <p><ul class="simple">
<li>if any symbol in <code class="docutils literal"><span class="pre">sym_vars</span></code> does not start with the letter &#8220;d&#8221;</li>
</ul>
</p>
</li>
<li><code class="first docutils literal"><span class="pre">unspecified</span></code> - <p>any exception thrown by:<ul class="simple">
<li>piranha::series::extend_symbol_set, </li>
</ul>
</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;std::enable_if_t&lt; piranha::is_differentiable&lt; Cf &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi5gdual9integrateERKNSt6stringE">
<span id="audi::gdual::integrate__ssCR"></span><span class="target" id="AuDiclassaudi_1_1gdual_1aff28ab4917c18532d20d15e32ad1ab5b"></span><a class="reference internal" href="#_CPPv2N4audi5gdualE" title="audi::gdual">gdual</a> <code class="descname">integrate</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>var_name</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi5gdual9integrateERKNSt6stringE" title="Permalink to this definition">¶</a></dt>
<dd><p>Integration. </p>
<p>Performs the integration of the gdual with respect to the symbol.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>If the <code class="docutils literal"><span class="pre">var_name</span></code> differential is not in the symbol set, then it is added.</dd>
<dt><strong>Note</strong></dt>
<dd>Information may be lost as the truncation order is preserved.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">var_name</span></code> - <p>Symbol name (cannot start with &#8220;d&#8221;).</p>
</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">std::invalid_argument</span></code> - <p><ul class="simple">
<li>if <code class="docutils literal"><span class="pre">var_name</span></code> starts with the letter &#8220;d&#8221; (this avoid creating confusing names for symbol&#8217;s differentials)</li>
</ul>
</p>
</li>
<li><code class="first docutils literal"><span class="pre">unspecified</span></code> - <p>any exception thrown by:<ul class="simple">
<li>piranha::series::truncate_degree,</li>
<li>piranha::series::integrate </li>
</ul>
</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;std::enable_if_t&lt; piranha::is_differentiable&lt; Cf &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi5gdual7partialERKNSt6stringE">
<span id="audi::gdual::partial__ssCR"></span><span class="target" id="AuDiclassaudi_1_1gdual_1af5cc133d2322b28fbd94e46876714d46"></span><a class="reference internal" href="#_CPPv2N4audi5gdualE" title="audi::gdual">gdual</a> <code class="descname">partial</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>var_name</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi5gdual7partialERKNSt6stringE" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial derivative. </p>
<p>Performs the partial derivative of the gdual with respect to the symbol</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>If the <code class="docutils literal"><span class="pre">var_name</span></code> differential is not in the symbol set, then it is added.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">var_name</span></code> - <p>Symbol name (cannot start with &#8220;d&#8221;).</p>
</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">std::invalid_argument</span></code> - <p><ul class="simple">
<li>if <code class="docutils literal"><span class="pre">symbol</span></code> starts with the letter &#8220;d&#8221; (this avoid creating confusing names for symbol&#8217;s differentials)</li>
</ul>
</p>
</li>
<li><code class="first docutils literal"><span class="pre">unspecified</span></code> - <p>any exception thrown by:<ul class="simple">
<li>piranha::series::partial, </li>
</ul>
</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T&gt;</dt>
<dt id="_CPPv2N4audi5gdual4subsERKNSt6stringERK1T">
<span id="audi::gdual::subs__ssCR.TCR"></span><span class="target" id="AuDiclassaudi_1_1gdual_1a355a0efdc1b5812058694c7cb8618c5f"></span><a class="reference internal" href="#_CPPv2N4audi5gdualE" title="audi::gdual">gdual</a> <code class="descname">subs</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>sym</em>, <em class="property">const</em> T &amp;<em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi5gdual4subsERKNSt6stringERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Substitute symbol with value. </p>
<p>Substitute the symbol <code class="docutils literal"><span class="pre">sym</span></code> with the value <code class="docutils literal"><span class="pre">val</span></code> </p>
<p><dl class="docutils">
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">unspecified</span></code> - <p>any exception thrown by:<ul class="simple">
<li>piranha::series::subs, </li>
</ul>
</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N4audi5gdual8evaluateERKNSt13unordered_mapINSt6stringEdEE">
<span id="audi::gdual::evaluate__std::unordered_map:ss.double:CR"></span><span class="target" id="AuDiclassaudi_1_1gdual_1acaa8de48a1c5189c371239fea6845324"></span>auto <code class="descname">evaluate</code><span class="sig-paren">(</span><em class="property">const</em> std::unordered_map&lt;std::string, double&gt; &amp;<em>dict</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N4audi5gdual8evaluateERKNSt13unordered_mapINSt6stringEdEE" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the Taylor polynomial. </p>
<p>Evaluates the Taylor polynomial using the values in <code class="docutils literal"><span class="pre">dict</span></code> for all the differentials (variables variations)</p>
<p><dl class="docutils">
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">unspecified</span></code> - <p>any exception thrown by:<ul class="simple">
<li>piranha::math::evaluate, </li>
</ul>
</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N4audi5gdual6degreeEv">
<span id="audi::gdual::degree"></span><span class="target" id="AuDiclassaudi_1_1gdual_1a1fa4a934c8b273aa5d8151049ef3a2e8"></span>auto <code class="descname">degree</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N4audi5gdual6degreeEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Current degree. </p>
<p>Returns the current degree of the polynomial represented as an <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>. This may be different from the truncation order <span class="math">\(m\)</span> and, in particular will be smaller or equal.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the current degree of the polynomial </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N4audi5gdual9get_orderEv">
<span id="audi::gdual::get_order"></span><span class="target" id="AuDiclassaudi_1_1gdual_1a52489a6b3c645dbf08e778c34aaa7172"></span>unsigned int <code class="descname">get_order</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N4audi5gdual9get_orderEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for the truncation order. </p>
<p>Returns the truncation order of the underlying <span class="math">\(\mathcal P_{n,m}\)</span> algebra.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the truncation order </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T&gt;</dt>
<dt id="_CPPv2N4audi5gdual7find_cfERK1T">
<span id="audi::gdual::find_cf__TCR"></span><span class="target" id="AuDiclassaudi_1_1gdual_1a44160236a6d54c0fe5235bc75c2f4f92"></span>auto <code class="descname">find_cf</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>c</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N4audi5gdual7find_cfERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the coefficient of a particular monomial. </p>
<p>Returns the coefficient of the monomial specified in the container <code class="docutils literal"><span class="pre">c</span></code> </p>
<p>
This method will first construct a term with zero coefficient and key initialised from the begin/end iterators of c and the symbol set of this, and it will then try to locate the term inside this. If the term is found, its coefficient will be returned. Otherwise, a coefficient initialised from 0 will be returned.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The container contains the exponents of the requested monomial. In a three variable polynomial with &#8220;x&#8221;, &#8220;y&#8221; and &#8220;z&#8221; as symbols, [1, 3, 2] would denote the term x y^3 z^2.</dd>
<dt><strong>Note</strong></dt>
<dd>Alphabetical order is used to order the symbol set and thus specify the coefficients.</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the coefficient</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">std::invalid_argument</span></code> - <p><ul class="simple">
<li>if the requested coefficient is beyond the truncation order </li>
</ul>
</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T&gt;</dt>
<dt id="_CPPv2N4audi5gdual7find_cfENSt16initializer_listI1TEE">
<span id="audi::gdual::find_cf__std::initializer_list:T:"></span><span class="target" id="AuDiclassaudi_1_1gdual_1a09c8b68f0b5da2b9251f7582f1fdcb43"></span>auto <code class="descname">find_cf</code><span class="sig-paren">(</span>std::initializer_list&lt;T&gt; <em>l</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N4audi5gdual7find_cfENSt16initializer_listI1TEE" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the coefficient of a particular monomial. </p>
<p>Returns the coefficient of the monomial specified in the initializer list <code class="docutils literal"><span class="pre">l</span></code> </p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This method is identical to the other overload with the same name, and it is provided for convenience.</dd>
<dt><strong>Return</strong></dt>
<dd>the coefficient</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">std::invalid_argument</span></code> - <p><ul class="simple">
<li>if the requested coefficient is beyond the truncation order </li>
</ul>
</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T&gt;</dt>
<dt id="_CPPv2N4audi5gdual14get_derivativeERK1T">
<span id="audi::gdual::get_derivative__TCR"></span><span class="target" id="AuDiclassaudi_1_1gdual_1a95fe275046ad679cf02458b5c01df566"></span>auto <code class="descname">get_derivative</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>c</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N4audi5gdual14get_derivativeERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the derivative value. </p>
<p>Returns the (mixed) derivative value of order specified by the container <code class="docutils literal"><span class="pre">c</span></code> </p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The container contains the order requested. In a three variable polynomial with &#8220;x&#8221;, &#8220;y&#8221; and &#8220;z&#8221; as symbols, [1, 3, 2] would denote the sixth order derivative <span class="math">\( \frac{d^6}{dxdy^3dz^2}\)</span>.</dd>
<dt><strong>Note</strong></dt>
<dd>No computations are made at this points as all derivatives are already contained in the Taylor expansion</dd>
<dt><strong>Return</strong></dt>
<dd>the value of the derivative</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">std::invalid_argument</span></code> - <p><ul class="simple">
<li>if the requested coefficient is beyond the truncation order </li>
</ul>
</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T&gt;</dt>
<dt id="_CPPv2N4audi5gdual14get_derivativeENSt16initializer_listI1TEE">
<span id="audi::gdual::get_derivative__std::initializer_list:T:"></span><span class="target" id="AuDiclassaudi_1_1gdual_1a2e1e08012060d7949dfe1c3685ae55f9"></span>auto <code class="descname">get_derivative</code><span class="sig-paren">(</span>std::initializer_list&lt;T&gt; <em>l</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N4audi5gdual14get_derivativeENSt16initializer_listI1TEE" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the derivative value. </p>
<p>Returns the (mixed) derivative value of order specified by the initializer list <code class="docutils literal"><span class="pre">l</span></code> </p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This method is identical to the other overload with the same name, and it is provided for convenience.</dd>
<dt><strong>Note</strong></dt>
<dd>No computations are made at this points as all derivatives are already contained in the Taylor expansion</dd>
<dt><strong>Return</strong></dt>
<dd>the value of the derivative</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">std::invalid_argument</span></code> - <p><ul class="simple">
<li>if the requested coefficient is beyond the truncation order </li>
</ul>
</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N4audi5gdual14get_derivativeERKNSt13unordered_mapINSt6stringEjEE">
<span id="audi::gdual::get_derivative__std::unordered_map:ss.unsigned-i:CR"></span><span class="target" id="AuDiclassaudi_1_1gdual_1a8369df8a0639de376504936848df22be"></span>auto <code class="descname">get_derivative</code><span class="sig-paren">(</span><em class="property">const</em> std::unordered_map&lt;std::string, unsigned int&gt; &amp;<em>dict</em><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N4audi5gdual14get_derivativeERKNSt13unordered_mapINSt6stringEjEE" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the derivative value. </p>
<p>Returns the (mixed) derivative value of order specified by the container <code class="docutils literal"><span class="pre">c</span></code> </p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>To get the following derivative: <span class="math">\( \frac{d^6}{dxdy^3dz^2}\)</span> the input should be {{&#8220;x&#8221;, 1u},{&#8220;y&#8221;,3u},{&#8220;z&#8221;,2u}}</dd>
<dt><strong>Note</strong></dt>
<dd>The current implementation call internally the other templated implementations. WHen piranha will implement the sparse monomial this will change and be more efficient.</dd>
<dt><strong>Return</strong></dt>
<dd>the value of the derivative</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">unspecified</span></code> - <p>all exceptions thrown by the templated version call. </p>
</li>
<li><code class="first docutils literal"><span class="pre">std::invalid_argument</span></code> - <p>if one of the symbols is not found in the expression </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N4audi5gdual11constant_cfEv">
<span id="audi::gdual::constant_cf"></span><span class="target" id="AuDiclassaudi_1_1gdual_1a67ab9efec70f6bdd8d1d44753fdb37a5"></span>Cf <code class="descname">constant_cf</code><span class="sig-paren">(</span><span class="sig-paren">)</span> const<a class="headerlink" href="#_CPPv2N4audi5gdual11constant_cfEv" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the constant coefficient. </p>
<p>Returns the coefficient of the of the constant part of the polynomial so that if <span class="math">\(T_{f} = f_0 + \hat f\)</span>,m <span class="math">\(f_0\)</span> is returned</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This method is identical to the other overload with the same name, and it is provided for convenience. </dd>
<dt><strong>Return</strong></dt>
<dd>the coefficient </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef container">
<p class="breathe-sectiondef-title rubric">Friends</p>
<dl class="function">
<dt id="_CPPv2lsRNSt7ostreamERK5gdual">
<span id="lshift-operator__osR.gdualCR"></span><span class="target" id="AuDiclassaudi_1_1gdual_1a191703f3624ccb362221632aabf57153"></span>std::ostream &amp;<code class="descname">operator&lt;&lt;</code><span class="sig-paren">(</span>std::ostream &amp;<em>os</em>, <em class="property">const</em> gdual &amp;<em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2lsRNSt7ostreamERK5gdual" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded stream operator. </p>
<p>Will direct to stream a human-readable representation of the generalized dual number. It uses the piranha overload for the type piranha::series. Refer to that documentation for further details</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The print order of the terms will be undefined. </dd>
<dt><strong>Note</strong></dt>
<dd>At most piranha::settings::get_max_term_output() terms are printed, and terms in excess are represented with ellipsis &#8221;...&#8221; at the end of the output; if piranha::settings::get_max_term_output() is zero, all the terms will be printed. piranha::settings::set_max_term_output() is used to set this parameter.</dd>
<dt><strong>Return</strong></dt>
<dd>reference to <code class="docutils literal"><span class="pre">os</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">os</span></code> - <p>target stream. </p>
</li>
<li><code class="first docutils literal"><span class="pre">d</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument.</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2eqRK5gdualRK5gdual">
<span id="eq-operator__gdualCR.gdualCR"></span><span class="target" id="AuDiclassaudi_1_1gdual_1ae45eafd4b2796ef03ded16067f847b20"></span>bool <code class="descname">operator==</code><span class="sig-paren">(</span><em class="property">const</em> gdual &amp;<em>d1</em>, <em class="property">const</em> gdual &amp;<em>d2</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2eqRK5gdualRK5gdual" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded Equality operator. </p>
<p>Compares the single polynomial coefficients of two <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> objects and returns true if equal.</p>
<p>/note The truncation order of <code class="docutils literal"><span class="pre">d1</span></code> and <code class="docutils literal"><span class="pre">d2</span></code> may be different</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The result of the cmparison </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d1</span></code> - <p>first <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument </p>
</li>
<li><code class="first docutils literal"><span class="pre">d2</span></code> - <p>second <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2neRK5gdualRK5gdual">
<span id="neq-operator__gdualCR.gdualCR"></span><span class="target" id="AuDiclassaudi_1_1gdual_1a1720b0c7b7fee3512708133495d9116c"></span>bool <code class="descname">operator!=</code><span class="sig-paren">(</span><em class="property">const</em> gdual &amp;<em>d1</em>, <em class="property">const</em> gdual &amp;<em>d2</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2neRK5gdualRK5gdual" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded Non equality operator. </p>
<p>Compares the truncation order and the single polynomial coefficients of two <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> objects and returns false if equal.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The result of the cmparison </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d1</span></code> - <p>first <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument </p>
</li>
<li><code class="first docutils literal"><span class="pre">d2</span></code> - <p>second <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>
<div class="section" id="functions">
<h2><a class="toc-backref" href="#id4">Functions</a><a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="exp-overload-for-the-exponential">
<h3><a class="toc-backref" href="#id5">exp: Overload for the exponential.</a><a class="headerlink" href="#exp-overload-for-the-exponential" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, std::enable_if_t&lt; is_gdual&lt; T &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi3expERK1T">
<span id="audi::exp__TCR"></span><span class="target" id="AuDinamespaceaudi_1af718491596ab5e7e7c4d683b72c01425"></span>T <code class="descclassname">audi::</code><code class="descname">exp</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi3expERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload for the exponential. </p>
<p>Implements the exponential of a <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>. Essentially it performs the following computations in the <span class="math">\(\mathcal P_{n,m}\)</span> algebra:</p>
<p><div class="math">
\[ T_{(\exp f)} = \exp f_0 \sum_{i=0}^m \frac{\hat f^i}{i!} = \exp f_0 \left( 1 + \hat f + \frac {\hat f^2}{2!} + ... \right) \]</div>
</p>
<p>where <span class="math">\(T_f = f_0 + \hat f\)</span>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an audi:gdual containing the Taylor expansion of the exponential of <code class="docutils literal"><span class="pre">d</span></code> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="log-overload-for-the-logarithm">
<h3><a class="toc-backref" href="#id6">log: Overload for the logarithm.</a><a class="headerlink" href="#log-overload-for-the-logarithm" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, std::enable_if_t&lt; is_gdual&lt; T &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi3logERK1T">
<span id="audi::log__TCR"></span><span class="target" id="AuDinamespaceaudi_1a340af557a8112eb193765c9591fd9486"></span>T <code class="descclassname">audi::</code><code class="descname">log</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi3logERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload for the logarithm. </p>
<p>Implements the logarithm of a <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>. Essentially it performs the following computations in the <span class="math">\(\mathcal P_{n,m}\)</span> algebra:</p>
<p><div class="math">
\[ T_{(\log f)} = \log f_0 + \sum_{i=1}^m (-1)^{i+1} \frac 1i \left(\frac{\hat f}{f_0}\right)^i = \log f_0 + \frac{\hat f}{f_0} - \frac 12 \left(\frac{\hat f}{f_0}\right)^2 + ... \]</div>
</p>
<p>where <span class="math">\(T_f = f_0 + \hat f\)</span>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an audi:gdual containing the Taylor expansion of the logarithm of <code class="docutils literal"><span class="pre">d</span></code> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="pow-overload-for-pow-const-gdual-double">
<h3><a class="toc-backref" href="#id7">pow: Overload for pow(const gdual&amp;, double)</a><a class="headerlink" href="#pow-overload-for-pow-const-gdual-double" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, std::enable_if_t&lt; is_gdual&lt; T &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi3powERK1Td">
<span id="audi::pow__TCR.double"></span><span class="target" id="AuDinamespaceaudi_1ac6c61b65bc79cc276da0f726cdc9c49f"></span>T <code class="descclassname">audi::</code><code class="descname">pow</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d</em>, double <em>alpha</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi3powERK1Td" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload for the exponentiation. </p>
<p>Implements the exponentiation of a <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>. Essentially it performs the following computations in the <span class="math">\(\mathcal P_{n,m}\)</span> algebra:</p>
<p><div class="math">
\[ T_{(f^\alpha)} = f_0^\alpha \sum_{k=0}^m {\alpha \choose k} \left(\hat f / f_0\right)^k \]</div>
</p>
<p>where <span class="math">\(T_f = f_0 + \hat f\)</span>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an audi:gdual containing the Taylor expansion of <code class="docutils literal"><span class="pre">d</span></code> elevated to the power <code class="docutils literal"><span class="pre">alpha</span></code> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument </p>
</li>
<li><code class="first docutils literal"><span class="pre">alpha</span></code> - <p>exponent</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="pow-overload-for-pow-const-gdual-int">
<h3><a class="toc-backref" href="#id8">pow: Overload for pow(const gdual&amp;, int)</a><a class="headerlink" href="#pow-overload-for-pow-const-gdual-int" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, std::enable_if_t&lt; is_gdual&lt; T &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi3powERK1Ti">
<span id="audi::pow__TCR.i"></span><span class="target" id="AuDinamespaceaudi_1af6b5e0cb1e76a1228fd89654aa3e77a2"></span>T <code class="descclassname">audi::</code><code class="descname">pow</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d</em>, int <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi3powERK1Ti" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload for the integer exponentiation. </p>
<p>Implements the integer exponentiation of a <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>. Essentially, it uses the <span class="math">\(\mathcal P_{n,m}\)</span> multiplication on <code class="docutils literal"><span class="pre">d</span></code> <code class="docutils literal"><span class="pre">n</span></code> times</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument </p>
</li>
<li><code class="first docutils literal"><span class="pre">n</span></code> - <p>integer exponent </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="pow-overload-for-pow-double-const-gdual">
<h3><a class="toc-backref" href="#id9">pow: Overload for pow(double, const gdual&amp;)</a><a class="headerlink" href="#pow-overload-for-pow-double-const-gdual" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, std::enable_if_t&lt; is_gdual&lt; T &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi3powEdRK1T">
<span id="audi::pow__double.TCR"></span><span class="target" id="AuDinamespaceaudi_1a5462fb27460af65be40fb3b84e2fc376"></span>T <code class="descclassname">audi::</code><code class="descname">pow</code><span class="sig-paren">(</span>double <em>base</em>, <em class="property">const</em> T &amp;<em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi3powEdRK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload for the exponentiation to a gdual power. </p>
<p>Computes the exponentiation to the power of an <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>. If the exponent is an integer constant, it calls the std::pow overload. Otherwise it converts <span class="math">\(a^{T_f}\)</span> to <span class="math">\(\exp(T_g*\log(a))\)</span> and computes this last expression instead.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">base</span></code> - <p>the base for the exponent </p>
</li>
<li><code class="first docutils literal"><span class="pre">d</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="pow-overload-for-pow-const-gdual-const-gdual">
<h3><a class="toc-backref" href="#id10">pow: Overload for pow(const gdual&amp;, const gdual&amp;)</a><a class="headerlink" href="#pow-overload-for-pow-const-gdual-const-gdual" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, std::enable_if_t&lt; is_gdual&lt; T &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi3powERK1TRK1T">
<span id="audi::pow__TCR.TCR"></span><span class="target" id="AuDinamespaceaudi_1a2543f5f5d672d8240648e5e029670c74"></span>T <code class="descclassname">audi::</code><code class="descname">pow</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d1</em>, <em class="property">const</em> T &amp;<em>d2</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi3powERK1TRK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload for the exponentiation of a gdual to a gdual power. </p>
<p>Computes the exponentiation of an <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> to the power of an <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>. If the exponent is an integer constant, it calls a different overload. Otherwise it converts <span class="math">\(T_f^{T_g}\)</span> to <span class="math">\(\exp(T_g*\log(T_f))\)</span> and computes this last expression instead.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d1</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument </p>
</li>
<li><code class="first docutils literal"><span class="pre">d2</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">std::domain_error</span></code> - <p>if std::log( <span class="math">\(f_0\)</span>) is not finite (uses std::isfinite) </p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="sin-overload-for-the-sine">
<h3><a class="toc-backref" href="#id11">sin: Overload for the sine.</a><a class="headerlink" href="#sin-overload-for-the-sine" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, std::enable_if_t&lt; is_gdual&lt; T &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi3sinERK1T">
<span id="audi::sin__TCR"></span><span class="target" id="AuDinamespaceaudi_1a1f140a1aafe6b61609798a234ecc6c8f"></span>T <code class="descclassname">audi::</code><code class="descname">sin</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi3sinERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload for the sine. </p>
<p>Implements the sine of a <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>. Essentially it performs the following computations in the <span class="math">\(\mathcal P_{n,m}\)</span> algebra:</p>
<p><div class="math">
\[\begin{split} T_{(\sin f)} = \sin f_0 \left(\sum_{i=0}^{2i\le m} (-1)^{i} \frac{\hat f^{2i}}{(2i)!}\right) + \cos f_0 \left(\sum_{i=0}^{(2i+1)\le m} (-1)^{i} \frac{\hat f^{2i+1}}{(2i+1)!}\right) \\ \end{split}\]</div>
</p>
<p>where <span class="math">\(T_f = f_0 + \hat f\)</span>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an audi:gdual containing the Taylor expansion of the sine of <code class="docutils literal"><span class="pre">d</span></code> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="cos-overload-for-the-cosine">
<h3><a class="toc-backref" href="#id12">cos: Overload for the cosine.</a><a class="headerlink" href="#cos-overload-for-the-cosine" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, std::enable_if_t&lt; is_gdual&lt; T &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi3cosERK1T">
<span id="audi::cos__TCR"></span><span class="target" id="AuDinamespaceaudi_1ac5bd00c020bfc3bb6f9727cacc927e80"></span>T <code class="descclassname">audi::</code><code class="descname">cos</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi3cosERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload for the cosine. </p>
<p>Implements the cosine of a <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>. Essentially it performs the following computations in the <span class="math">\(\mathcal P_{n,m}\)</span> algebra:</p>
<p><div class="math">
\[ T_{(\cos f)} = \cos f_0 \left(\sum_{i=0}^{2i\le m} (-1)^{i} \frac{\hat f^{2i}}{(2i)!}\right) - \sin f_0 \left(\sum_{i=0}^{(2i+1)\le m} (-1)^{i} \frac{\hat f^{2i+1}}{(2i+1)!}\right) \]</div>
</p>
<p>where <span class="math">\(T_f = f_0 + \hat f\)</span>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an audi:gdual containing the Taylor expansion of the cosine of <code class="docutils literal"><span class="pre">d</span></code> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="sin-and-cos-computes-both-at-once">
<h3><a class="toc-backref" href="#id13">sin_and_cos: Computes both at once</a><a class="headerlink" href="#sin-and-cos-computes-both-at-once" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, std::enable_if_t&lt; is_gdual&lt; T &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi11sin_and_cosERK1T">
<span id="audi::sin_and_cos__TCR"></span><span class="target" id="AuDinamespaceaudi_1ac10deb6e5f72665371505bdf08ac2dc9"></span>std::array&lt;T, 2&gt; <code class="descclassname">audi::</code><code class="descname">sin_and_cos</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi11sin_and_cosERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes both sine and cosine. </p>
<p>As most of the computations for the sine and cosine is the same, it is twice as fast to get both sine and cosine at once rather than computing them in sequence. Use this function when both sine and cosine are needed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an std::array containing the Taylor expansions of sine and the cosine (first element, second element) </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="tan-overload-for-the-tangent">
<h3><a class="toc-backref" href="#id14">tan: Overload for the tangent.</a><a class="headerlink" href="#tan-overload-for-the-tangent" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, std::enable_if_t&lt; is_gdual&lt; T &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi3tanERK1T">
<span id="audi::tan__TCR"></span><span class="target" id="AuDinamespaceaudi_1a817157267b65e8ed47956e930ddb8bd4"></span>T <code class="descclassname">audi::</code><code class="descname">tan</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi3tanERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload for the tangent. </p>
<p>Implements the tangent of a <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>. Essentially, it performs the following computations in the <span class="math">\(\mathcal P_{n,m}\)</span> algebra:</p>
<p><div class="math">
\[ T_{(\tan f)} = \frac{\tan f_0 + \sum_{k=1}^{k \le 2k+1} B_{2k} \frac{(-4)^k(1-4^k)}{2k!}x^{2k - 1}}{1 - \tan f_0 \sum_{k=1}^{k \le 2k+1} \frac{B_{2k}(-4)^k(1-4^k)}{2k!}x^{2k - 1} } \]</div>
</p>
<p>where <span class="math">\(T_f = f_0 + \hat f\)</span> and <span class="math">\( B_{2k}\)</span> are the Bernoulli numbers.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an audi:gdual containing the Taylor expansion of the tangent of <code class="docutils literal"><span class="pre">d</span></code> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="atan-overload-for-the-inverse-tangent">
<h3><a class="toc-backref" href="#id15">atan: Overload for the inverse  tangent.</a><a class="headerlink" href="#atan-overload-for-the-inverse-tangent" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, std::enable_if_t&lt; is_gdual&lt; T &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi4atanERK1T">
<span id="audi::atan__TCR"></span><span class="target" id="AuDinamespaceaudi_1a003bc73373876546a0deecb2dfd104af"></span>T <code class="descclassname">audi::</code><code class="descname">atan</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi4atanERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload for the inverse tangent. </p>
<p>Implements the inverse tangent of an <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>. Essentially, it performs the following computations in the <span class="math">\(\mathcal P_{n,m}\)</span> algebra:</p>
<p><div class="math">
\[ T_{(\mbox{atan} f)} = \mbox{atan} f_0 + \sum_{k=1}^{2k-1\le m} \left(\frac{1 + \sum_{j=1}^{2j\le 2k-1} {2k-1 \choose 2j} f_0^{2j}(-1)^j}{(1+f_0^2)^{2k-1}}\right) \frac {\hat f^{2k-1}}{2k-1}(-1)^{k+1} + \sum_{k=1}^{2k\le m} \left(\frac{\sum_{j=1}^{2j-1\le 2k} {2k \choose 2j-1} f_0^{2j-1}(-1)^{j+1}}{(1+f_0^2)^{2k}}\right) \frac {\hat f^{2k}}{2k}(-1)^k \]</div>
</p>
<p>This formula derives directly from the formula for <a class="reference internal" href="#AuDinamespaceaudi_1a0cd869475ee9813d9b814218b9ce386f"><span class="std std-ref">audi::atanh</span></a> noting that: <span class="math">\( \mbox{atan}(z) = i \mbox{atanh}(-iz)\)</span></p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> containing the Taylor expansion of the inverse tangent of <code class="docutils literal"><span class="pre">d</span></code> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="acos-overload-for-the-inverse-cosine">
<h3><a class="toc-backref" href="#id16">acos: Overload for the inverse cosine.</a><a class="headerlink" href="#acos-overload-for-the-inverse-cosine" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, std::enable_if_t&lt; is_gdual&lt; T &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi4acosERK1T">
<span id="audi::acos__TCR"></span><span class="target" id="AuDinamespaceaudi_1a024e4663bd050837967e4807f98e2d7c"></span>T <code class="descclassname">audi::</code><code class="descname">acos</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi4acosERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload for the inverse cosine. </p>
<p>Implements the inverse inverse cosine of an <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>. Essentially, it performs the following computations in the <span class="math">\(\mathcal P_{n,m}\)</span> algebra:</p>
<p><div class="math">
\[ T_{(\mbox{acos} f)} = T_{\left(\mbox{atan} \left(\sqrt{1 - f^2} / f\right)\right)} \]</div>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> containing the Taylor expansion of the inverse cosine of <code class="docutils literal"><span class="pre">d</span></code> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="asin-overload-for-the-inverse-sine">
<h3><a class="toc-backref" href="#id17">asin: Overload for the inverse sine.</a><a class="headerlink" href="#asin-overload-for-the-inverse-sine" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, std::enable_if_t&lt; is_gdual&lt; T &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi4asinERK1T">
<span id="audi::asin__TCR"></span><span class="target" id="AuDinamespaceaudi_1a4d069b291d2deec3d4e4d9ffb120a226"></span>T <code class="descclassname">audi::</code><code class="descname">asin</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi4asinERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload for the inverse sine. </p>
<p>Implements the inverse inverse sine of an <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>. Essentially, it performs the following computations in the <span class="math">\(\mathcal P_{n,m}\)</span> algebra:</p>
<p><div class="math">
\[ T_{(\mbox{asin} f)} = T_{\left(\mbox{atan} \left(f / \sqrt{1 - f^2}\right)\right)} \]</div>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> containing the Taylor expansion of the inverse sine of <code class="docutils literal"><span class="pre">d</span></code> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="sinh-overload-for-the-hyperbolic-sine">
<h3><a class="toc-backref" href="#id18">sinh: Overload for the hyperbolic sine.</a><a class="headerlink" href="#sinh-overload-for-the-hyperbolic-sine" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, std::enable_if_t&lt; is_gdual&lt; T &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi4sinhERK1T">
<span id="audi::sinh__TCR"></span><span class="target" id="AuDinamespaceaudi_1a27049e5825941e639e48a8f2709d0423"></span>T <code class="descclassname">audi::</code><code class="descname">sinh</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi4sinhERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload for the hyperbolic sine. </p>
<p>Implements the hyperbolic sine of a <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>. Essentially it performs the following computations in the <span class="math">\(\mathcal P_{n,m}\)</span> algebra:</p>
<p><div class="math">
\[\begin{split} T_{(\sin f)} = \sinh f_0 \left(\sum_{i=0}^{2i\le m} \frac{\hat f^{2i}}{(2i)!}\right) + \cosh f_0 \left(\sum_{i=0}^{(2i+1)\le m} \frac{\hat f^{2i+1}}{(2i+1)!}\right) \\ \end{split}\]</div>
</p>
<p>where <span class="math">\(T_f = f_0 + \hat f\)</span>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an audi:gdual containing the Taylor expansion of the hyperbolic sine of <code class="docutils literal"><span class="pre">d</span></code> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="cosh-overload-for-the-hyperbolic-cosine">
<h3><a class="toc-backref" href="#id19">cosh: Overload for the hyperbolic cosine.</a><a class="headerlink" href="#cosh-overload-for-the-hyperbolic-cosine" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, std::enable_if_t&lt; is_gdual&lt; T &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi4coshERK1T">
<span id="audi::cosh__TCR"></span><span class="target" id="AuDinamespaceaudi_1ae337ffc34e7587d3d67a68a6bccf0708"></span>T <code class="descclassname">audi::</code><code class="descname">cosh</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi4coshERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload for the hyperbolic cosine. </p>
<p>Implements the hyperbolic cosine of a <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>. Essentially it performs the following computations in the <span class="math">\(\mathcal P_{n,m}\)</span> algebra:</p>
<p><div class="math">
\[\begin{split} T_{(\sin f)} = \cosh f_0 \left(\sum_{i=0}^{2i\le m} \frac{\hat f^{2i}}{(2i)!}\right) + \sinh f_0 \left(\sum_{i=0}^{(2i+1)\le m} \frac{\hat f^{2i+1}}{(2i+1)!}\right) \\ \end{split}\]</div>
</p>
<p>where <span class="math">\(T_f = f_0 + \hat f\)</span>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an audi:gdual containing the Taylor expansion of the hyperbolic cosine of <code class="docutils literal"><span class="pre">d</span></code> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="sinh-and-cosh-computes-both-at-once">
<h3><a class="toc-backref" href="#id20">sinh_and_cosh: Computes both at once</a><a class="headerlink" href="#sinh-and-cosh-computes-both-at-once" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, std::enable_if_t&lt; is_gdual&lt; T &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi13sinh_and_coshERK1T">
<span id="audi::sinh_and_cosh__TCR"></span><span class="target" id="AuDinamespaceaudi_1ac6c185c78b02e11e4cab4b0e78ebc74f"></span>std::array&lt;T, 2&gt; <code class="descclassname">audi::</code><code class="descname">sinh_and_cosh</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi13sinh_and_coshERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes both the hyperbolic sine and the hyperbolic cosine. </p>
<p>As most of the computations for the hyperbolic sine and hyperbolic cosine is the same, it is twice as fast to get them both at once rather than computing them in sequence. Use this function when both the hyperbolic sine and the hyperbolic cosine are needed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an std::array containing the Taylor expansions of hyperbolic sine and cosine (first element, second element) </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="tanh-overload-for-the-hyperbolic-tangent">
<h3><a class="toc-backref" href="#id21">tanh: Overload for the hyperbolic tangent.</a><a class="headerlink" href="#tanh-overload-for-the-hyperbolic-tangent" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, std::enable_if_t&lt; is_gdual&lt; T &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi4tanhERK1T">
<span id="audi::tanh__TCR"></span><span class="target" id="AuDinamespaceaudi_1a53839c3938f9f808abaa8d22f9843f4d"></span>T <code class="descclassname">audi::</code><code class="descname">tanh</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi4tanhERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload for the hyperbolic tangent. </p>
<p>Implements the hyperbolic tangent of a <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>. Essentially, it performs the following computations in the <span class="math">\(\mathcal P_{n,m}\)</span> algebra:</p>
<p><div class="math">
\[ T_{(\tan f)} = \frac{\tanh f_0 + \sum_{k=1}^{k \le 2k+1} B_{2k} \frac{4^k(4^k-1)}{2k!}x^{2k - 1}}{1 + \tanh f_0 \sum_{k=1}^{k \le 2k+1} \frac{B_{2k}4^k(4^k-1)}{2k!}x^{2k - 1} } \]</div>
</p>
<p>where <span class="math">\(T_f = f_0 + \hat f\)</span> and <span class="math">\( B_{2k}\)</span> are the Bernoulli numbers.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> containing the Taylor expansion of the hyperbolic tangent of <code class="docutils literal"><span class="pre">d</span></code> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="atanh-overload-for-the-inverse-hyperbolic-tangent">
<h3><a class="toc-backref" href="#id22">atanh: Overload for the inverse hyperbolic tangent.</a><a class="headerlink" href="#atanh-overload-for-the-inverse-hyperbolic-tangent" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, std::enable_if_t&lt; is_gdual&lt; T &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi5atanhERK1T">
<span id="audi::atanh__TCR"></span><span class="target" id="AuDinamespaceaudi_1a0cd869475ee9813d9b814218b9ce386f"></span>T <code class="descclassname">audi::</code><code class="descname">atanh</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi5atanhERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload for the inverse hyperbolic tangent. </p>
<p>Implements the inverse hyperbolic tangent of an <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>. Essentially, it performs the following computations in the <span class="math">\(\mathcal P_{n,m}\)</span> algebra:</p>
<p><div class="math">
\[ T_{(\mbox{atanh} f)} = \mbox{atanh} f_0 +\frac 12 \sum_{k=1}^m \left(\frac{1}{(1-f_0)^k} + \frac{(-1)^{k+1}}{(1+f_0)^k}\right) \frac {\hat f^k}{k} \]</div>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> containing the Taylor expansion of the inverse hyperbolic tangent of <code class="docutils literal"><span class="pre">d</span></code> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="acosh-overload-for-the-inverse-hyperbolic-cosine">
<h3><a class="toc-backref" href="#id23">acosh: Overload for the inverse hyperbolic cosine.</a><a class="headerlink" href="#acosh-overload-for-the-inverse-hyperbolic-cosine" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, std::enable_if_t&lt; is_gdual&lt; T &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi5acoshERK1T">
<span id="audi::acosh__TCR"></span><span class="target" id="AuDinamespaceaudi_1a58a5d1009aa817910947f8022b116feb"></span>T <code class="descclassname">audi::</code><code class="descname">acosh</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi5acoshERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload for the inverse hyperbolic cosine. </p>
<p>Implements the inverse inverse hyperbolic cosine of an <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>. Essentially, it performs the following computations in the <span class="math">\(\mathcal P_{n,m}\)</span> algebra:</p>
<p><div class="math">
\[ T_{(\mbox{acosh} f)} = T_{\left(\log\left(f + \sqrt{f^2 - 1}\right)\right)} \]</div>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> containing the Taylor expansion of the inverse hyperbolic cosine of <code class="docutils literal"><span class="pre">d</span></code> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="asinh-overload-for-the-inverse-hyperbolic-sine">
<h3><a class="toc-backref" href="#id24">asinh: Overload for the inverse hyperbolic sine.</a><a class="headerlink" href="#asinh-overload-for-the-inverse-hyperbolic-sine" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, std::enable_if_t&lt; is_gdual&lt; T &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi5asinhERK1T">
<span id="audi::asinh__TCR"></span><span class="target" id="AuDinamespaceaudi_1a52b02566a435b59a6408b5436b0770f5"></span>T <code class="descclassname">audi::</code><code class="descname">asinh</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi5asinhERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload for the inverse hyperbolic sine. </p>
<p>Implements the inverse inverse hyperbolic sine of an <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>. Essentially, it performs the following computations in the <span class="math">\(\mathcal P_{n,m}\)</span> algebra:</p>
<p><div class="math">
\[ T_{(\mbox{asinh} f)} = T_{\left(\log\left(f + \sqrt{1 + f^2}\right)\right)} \]</div>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> containing the Taylor expansion of the inverse hyperbolic sine of <code class="docutils literal"><span class="pre">d</span></code> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="erf-overload-for-the-error-function">
<h3><a class="toc-backref" href="#id25">erf: Overload for the error function</a><a class="headerlink" href="#erf-overload-for-the-error-function" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, std::enable_if_t&lt; is_gdual&lt; T &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi3erfERK1T">
<span id="audi::erf__TCR"></span><span class="target" id="AuDinamespaceaudi_1acaf9539a3d61171dca7125c4cbf417d6"></span>T <code class="descclassname">audi::</code><code class="descname">erf</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi3erfERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload for the error function. </p>
<p>Implements the error function of an <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>. Essentially it makes use of the fact that <span class="math">\( \frac{d erf(x)}{dx} = \frac{2}{\sqrt{\pi}}\exp(-x^2)\)</span> to then use audi::_compose_from_derivative</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an audi:gdual containing the Taylor expansion of the error function of <code class="docutils literal"><span class="pre">d</span></code> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">f</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="sqrt-overload-for-the-square-root">
<h3><a class="toc-backref" href="#id26">sqrt: Overload for the square root.</a><a class="headerlink" href="#sqrt-overload-for-the-square-root" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, std::enable_if_t&lt; is_gdual&lt; T &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi4sqrtERK1T">
<span id="audi::sqrt__TCR"></span><span class="target" id="AuDinamespaceaudi_1ac2e50a1a30ac40226f38f53165430588"></span>T <code class="descclassname">audi::</code><code class="descname">sqrt</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi4sqrtERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload for the square root. </p>
<p>Implements the square root of a <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>. Essentially it performs the following computations in the <span class="math">\(\mathcal P_{n,m}\)</span> algebra:</p>
<p><div class="math">
\[ T_{\sqrt{f}} = \sqrt{f_0} \sum_{k=0}^m {\frac 12 \choose k} \left(\hat f / f_0\right)^k \]</div>
</p>
<p>where <span class="math">\(T_f = f_0 + \hat f\)</span>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an audi:gdual containing the Taylor expansion of the square root of <code class="docutils literal"><span class="pre">d</span></code> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="cbrt-overload-for-the-cubic-root">
<h3><a class="toc-backref" href="#id27">cbrt: Overload for the cubic root.</a><a class="headerlink" href="#cbrt-overload-for-the-cubic-root" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, std::enable_if_t&lt; is_gdual&lt; T &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi4cbrtERK1T">
<span id="audi::cbrt__TCR"></span><span class="target" id="AuDinamespaceaudi_1a7ed9d4b57223f9e356c92258d37a6875"></span>T <code class="descclassname">audi::</code><code class="descname">cbrt</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi4cbrtERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload for the cubic root. </p>
<p>Implements the cubic root of a <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>. Essentially it performs the following computations in the <span class="math">\(\mathcal P_{n,m}\)</span> algebra:</p>
<p><div class="math">
\[ T_{\sqrt[3]{f}} = \sqrt[3]{f_0} \sum_{k=0}^m {\frac 13 \choose k} \left(\hat f / f_0\right)^k \]</div>
</p>
<p>where <span class="math">\(T_f = f_0 + \hat f\)</span>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an audi:gdual containing the Taylor expansion of the square root of <code class="docutils literal"><span class="pre">d</span></code> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<hr class="docutils" />
<div class="section" id="abs-overload-for-the-absolute-value">
<h3><a class="toc-backref" href="#id28">abs: Overload for the absolute value.</a><a class="headerlink" href="#abs-overload-for-the-absolute-value" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T, std::enable_if_t&lt; is_gdual&lt; T &gt;::value &amp;&amp;std::is_arithmetic&lt; typename T::cf_type &gt;::value, int &gt; = 0&gt;</dt>
<dt id="_CPPv2N4audi3absERK1T">
<span id="audi::abs__TCR"></span><span class="target" id="AuDinamespaceaudi_1a190187f6cbdafdc9baefcda8e313965e"></span>T <code class="descclassname">audi::</code><code class="descname">abs</code><span class="sig-paren">(</span><em class="property">const</em> T &amp;<em>d</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N4audi3absERK1T" title="Permalink to this definition">¶</a></dt>
<dd><p>Overload for the absolute value. </p>
<p>Implements the absolute value of a <a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a>. Essentially, it inverts the sign of <span class="math">\(T_f\)</span> as follows:</p>
<p><div class="math">
\[\begin{split} T_{(\mbox{abs} f)} = \left\{ \begin{array}{ll} T_f &amp; f_0 \ge 0 \\ -T_f &amp; f_0 &lt; 0 \end{array} \right. \end{split}\]</div>
</p>
<p>where <span class="math">\(T_f = f_0 + \hat f\)</span>.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>If <span class="math">\(f_0\)</span> is zero, the right Taylor expansion will be returned rather than nans.</dd>
<dt><strong>Note</strong></dt>
<dd>This operation is not availiable for std::complex types.</dd>
<dt><strong>Return</strong></dt>
<dd>an audi:gdual containing the Taylor expansion of the absoute value of <code class="docutils literal"><span class="pre">d</span></code> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last">
<li><code class="first docutils literal"><span class="pre">d</span></code> - <p><a class="reference internal" href="#AuDiclassaudi_1_1gdual"><span class="std std-ref">audi::gdual</span></a> argument</p>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2015, Dario Izzo &amp; Francesco Biscani.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.5.<br/>
    </p>
  </div>
</footer>
  </body>
</html>